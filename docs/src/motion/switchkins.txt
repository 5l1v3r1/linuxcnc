[[cha:switchable-kinematics]]

= Switchable Kinematics (switchkins)

== Introduction

A number of kinematics modules support the switching of
kinematics calculations.  These modules support a default
kinematics method (type0), a second built-in method (type1), and
(optionally) a user-provided kinematics method (type2).
Identity kinematics are typically used for the type1 method.

The switchkins functionality can be used for machines where
post-homing joint control is needed during setup or to avoid
movement near singularities from gcode.  Such machines use
specific kinematics calculations for most operations but can be
switched to identity kinematics for control of individual joints
after homing.

The kinematics type is selected by a motion module hal pin that
can be updated from a gcode program or by interactive MDI
commands.  The halui provisions for activating MDI commands can be
used to allow buttons to select the kinematics type using
hardware controls or a virtual panel (pyvcp,gladevcp, etc.).

When a kinematics type is changed, the gcode must also issue
commands to *force synchronization* of the interpreter and motion
parts of LinuCNC.  Typically, a hal pin read command (M66 E0 L0) is
used before and after altering the controlling hal pin to force
synchronization with no additional side-effects.

== Hal Pins

Kinematics switching is controlled by the motion module input hal
pin *motion.switchkins-type*.  The floating point pin value is
truncated to integer and used to select one of the provided
kinematics types.  The zero startup value selects the type0
default kinematics type.

Output hal pins are provided to inform guis of the current
kinematics type.  These pins can also be connected to digital
inputs that are read by gcode programs to enable or disable
program behavior in accordance with the active kinematics type.

=== Hal Pin Summary

. *motion.switchkins-type*  Input  (float)
. *kinstype.is-0*           Output (bit)
. *kinstype.is-1*           Output (bit)
. *kinstype.is-2*           Output (bit)

== Usage

=== Hal Connections

Switchkins functionality is enabled by the pin
motion.switchkins-type.  Typically, this pin is sourced by an
analog output pin like motion.analog-out-03 so that it can be
set/reset by M68 commands.  Example:

----
net :kinstype-select <= motion.analog-out-03
net :kinstype-select => motion.switchkins-type
----

=== Gcode/Mcode commands

Kinstype selection is managed using gcode sequences like:

----
...
M66 E0 L0 ;sync interp-motion
M68 E3 Q1 ;update analog-out-03 to select kinstype 1
M66 E0 L0 ;sync interp-motion
...
...       ;user gcode
...
M66 E0 L0 ;sync interp-motion
M68 E3 Q1 ;update analog-out-03 to select kinstype 0
M66 E0 L0 ;sync interp-motion
...
----

These gcode command sequences are typically implemented in
gcode subroutines as remapped Mcodes or with conventional
Mcode scripts.

Suggested codes (as used in sim configs) are:

Conventional User Mcodes:

. M128 Select kinstype 0 (startup default kinematics)
. M129 Select kinstype 1 (typically identity kinematics)
. M130 Select kinstype 2 (user-provided kinematics)

Remapped Mcodes:

. M428 Select kinstype 0 (startup default kinematics)
. M429 Select kinstype 1 (typically identity kinematics)
. M430 Select kinstype 2 (user-provided kinematics)

[NOTE]
Conventional user Mcodes (in the range M100-M199) are in modal
group 10.  Remapped Mcodes (in the range M200 to M999) can
specify a modalgroup.  See the remap documentation for additional
information.

=== Inifile Limit settings

LinuxCNC trajectory planning uses limits for postion (min,max),
velocity, and acceleration for each applicable coordinate letter
specified in the configuration ini file.  Example for letter L
(in the set 'XYZABCUVW'):

----
[AXIS_L]
MIN_LIMIT =
MAX_LIMIT =
MAX_VELOCITY =
MIN_ACCELERATION =
----

The inifile limits specified apply to the type 0 default
kinematics type that is activated at startup.  These limits may
*not* be applicable when switching to alternative kinematics.
However, since an interpreter-motion synchronization is required
when switching kinematics, ini-hal pins can be used to setup
limits for the next kinematics type.

[NOTE]
Ini-hal pins are typically not recognized during a gcode program
unless a synchronization (queue-buster) command is issued.  See
the milltask manpage for more information ($ man milltask)

The relevant ini-hal pins for a joint number (N) are:

----
ini.N.min_limit
ini.N.max_limit
ini.N.max_acceleration
ini.N.max_velocity
----

The relevant ini-hal pins for an axis coordinate (L) are:

----
ini.L.min_limit
ini.L.max_limit
ini.L.max_velocity
ini.L.max_acceleration
----

[NOTE]
In general, there are no fixed mappings between joint numbers and
axis coordinate letters.  There may be specific mappings for some
kinematics modules especially those that implement identity
kinematics (trivkins).  See the kins man page for more
information ($ man kins)

A user-provided Mcode can alter any or all of the axis letter
limits prior to synchronizing and changing the motion.switckins-type
pin.

Example:  An robot starts with a complex (non-identity)
kinematics (type 0) after homing.  The system is configured so that
it can be switched to identity kinematics (type 1) in order
to manipulate individual joints using the conventional letters
from the set 'XYZABCUVW'.  The ini file settings ([AXIS_L]) are
*not* applicable when operating with identity (type 1)
kinematics.  To address this usecase, the user Mcode scripts
can be designed as follows:

*M129* (Switch to identity type 1)
. read and parse ini file
. set the ini-hal limit pins for each axis letter ([AXIS_L])
according to the 'identical' joint number ini file setting ([JOINT_N])
. execute a synching gcode (M66E0L0)
. setp motion.switchkins-type 1
. execute a synching gcode (M66E0L0)

*M128* (restore robot default kinematics type 0)
. read and parse ini file
. set the ini-hal limit pins for each axis letter ([AXIS_L])
according to the appropriate inifile setting ([AXIS_L])
. execute a synching gcode (M66E0L0)
. setp motion.switchkins-type 0
. execute a synching gcode (M66E0L0)

[NOTE]
The vismach simulation configurations for a puma robot demonstrate
Mcode scripts (M128,M129) for this example usecase.

=== Offset considerations

Like inifile limit settings, coordinate sytem offsets (G92,
G10L2, G10L20, G43, etc) are generally applicable only for the
type 0 default startup kinematics type.  When switching
kinematics types, it may be *important* to either reset all offsets
prior to switching or update offsets based on system-specific
requirements.

== Switchable Kinematic Modules

The following kinematics modules support switchable kinematics:

. *xyzac-trt-kins* (type0:identity   type1:xyzac-trt-kins)
. *xyzbc-trt-kins* (type0:identity   type1:xyzbc-trt-kins)
. *genserkins*     (type0:genserkins type1:identity)
. *genhexkins*     (type0:genhexkins type1:identity)
. *pumakins*       (type0:pumakins   type1:identity)
. *scarakins*      (type0:scarakins  type1:identity)

The xyz[ab]c-trt-kins modules by default use
type0==xyz[ab]c-trt-kins for backwards compatibility.  The sim
configs alter the type 0/type 1 convention by forcing
type0==identity kinematics using the module string parameter
'sparms' with an inifile setting like:

----
[KINS]
KINEMATICS = xyzac-trt-kins sparm=identityfirst
...
----

=== Identity letter assignments

When using an identity kinematics type, the module parameter
'coordinates' can be used to assign letters to joints in
arbitrary order from the set of allowed coordinate letters.
Examples:

----
[KINS]
# conventional identity ordering: x==joint0, y==joint1, ...
KINEMATICS = genhexkins coordinates=xyzabc

# custom identity ordering: c==joint0, b==joint1, ...
KINEMATICS = genhexkins coordinates=cbazyx
----

This flexibility is similar to that provided for the common
identity kinematics module (trivkins) except duplication of axis
letters is not generally allowed as it is for trivkins.

=== Backwards compatibility

Switchable kinematics initalize with motion.switckins-type==0
implementing their eponymous kinematics method.  If the the
motion.switchkins-type pin is not connected -- as in historical
configurations -- only the default kinematics type is available.

== Simulation configs

Simulation configs (requiring no hardware) are provided with
illustrative vismach displays in subdirectories of
configs/sim/axis/vismach/

. 5axis/table-rotary-tilting/xyzac-trt.ini (xyzac-trt-kins)
. 5axis/table-rotary-tilting/xyzbc-trt.ini (xyzac-trt-kins)
. scara/scara.ini (scarakins)
. puma/puma.ini (pumakins)
. hexapod-sim/hexapod.ini (genhexkins)
. puma/puma560.ini (genserkins)

== User kinematics provisions

Custom kinematics can be coded and tested on Run-in-Place builds.
A template file src/emc/kinematics/userk.c is provided in the
distribution.  This file can be copied/renamed to a user
directory and edited to supply custom kinematics with kinstype==2.

The user custom kinematics file can be compiled from out-of-tree
source locations for rt-preempt implementations or by replacing
the in-tree template file (src/emc/kinematics/userk.c) for rtai
systems.

Preempt-rt make example:

----
$ userkfuncs=/home/myname/kins/mykins.c make && sudo make setuid
----

=== Warnings

Unexpected behavior can result if a gcode program is inadvertently
started with an incompatible kinematics type.  Unwanted behavior
can be circumvented in gcode programs by:

. Connecting appropriate kinstype.is.N hal pins to digital input
pins (like motion.digital-in-0m).

. Reading the digitial input pin (M66 E0 Pm) at the start of the
gcode program

. Aborting (M2) the gcode proram with a message (DEBUG, problem_message)
if the kinstype is not suitable.

When using jogging facilities or MDI commands interactively,
operator caution is required.  Guis should include indicators to
display the current kinematics type.

[NOTE]
Switching kinematics can cause substantial operational changes
requiring careful design, testing, and training for deployment.
The management of coordinate offsets, tool compensation, and
inifile limits may require complicated and non-standard operating
protocols.

== Code Notes

Kinematic modules providing switchkins functionality are linked
to the switchkins.o object (switchkins.c) that provides the
module 'main' program (rtapi_app_main()).  This 'main' program
reads (optional) module command-line parameters (coordinates,
sparm) and passes them to the module-provided function
switchkinsSetup().

The switchkinsSetup() function identifies type-specific setup
routines and the functions for forward an inverse calculation for
each kinstype (0,1,2) and sets a number of configuration
settings.

After calling switchkinsSetup(), rtapi_app_main() checks the
supplied parameters, creates a hal component, and then invokes
the setup routine identified for each kinstype (0,1,2).

Each kinstype (0,1,2) setup routine can (optionally) create hal
pins and set them to default values.  When all setup routines,
finish, rtapi_app_main() issues hal_ready() for the component
to complete creation of the module.
